{"version":3,"file":"Dispatcher.js","sourceRoot":"","sources":["Dispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { LogLevel } from './Types';\nimport { MessageEntity, MessageTag } from './Entities/MessageEntity';\nimport { AbstractTarget } from './Targets/AbstractTarget';\nimport { StackFrame } from 'stacktrace-parser';\nimport * as stackTraceParser from 'stacktrace-parser';\nimport { LoggerConfigInterface, TargetConfigInterface } from './Interface/LoggerConfigInterface';\n\nexport class Dispatcher implements LoggerConfigInterface {\n    // eslint-disable-next-line no-undef\n    public flushBySignals: NodeJS.Signals[] = [];\n\n    public flushByCountInterval = 1000;\n\n    public flushByTimeInterval = 0;\n\n    public traceLevel = 0;\n\n    public targets: TargetConfigInterface[] = [];\n\n    private messages: MessageEntity[] = [];\n\n    // eslint-disable-next-line no-undef\n    private flushByTimeIntervalTimer: NodeJS.Timer | null = null;\n\n    public constructor(config: LoggerConfigInterface) {\n        this.configure(config);\n        this.init();\n    }\n\n    public configure(config: LoggerConfigInterface): void {\n        Object.keys(config).forEach(value => {\n            this[value] = config[value];\n        });\n    }\n\n    public init(): void {\n        // @ts-ignore\n        process.flushLogs = async function() {\n            const msgToFlush = this.messages;\n            this.messages = [];\n            await this.flush(msgToFlush, true);\n        }.bind(this);\n\n        this.flushBySignals.forEach((signal) => {\n            process.on(signal, () => {\n                (async() => {\n                    const msgToFlush = this.messages;\n                    this.messages = [];\n                    await this.flush(msgToFlush, true);\n                })();\n            });\n        });\n        if (this.flushByTimeInterval > 0) {\n            this.flushByTimeIntervalTimer = setInterval(() => {\n                (async() => {\n                    if (this.messages.length !== 0) {\n                        const msgToFlush = this.messages;\n                        this.messages = [];\n                        return await this.flush(msgToFlush);\n                    }\n                })();\n            }, this.flushByTimeInterval);\n        }\n        process.on('exit', () => {\n            clearInterval(this.flushByTimeIntervalTimer);\n        });\n    }\n\n    public log(message: string, level: LogLevel, data?: any, category = 'application', tags?: MessageTag[]): void {\n        const time = new Date();\n        const traces: StackFrame[] = [];\n        if (this.traceLevel > 0) {\n            let count = 0;\n            const trace = stackTraceParser.parse(new Error().stack);\n            trace.pop();\n            trace.map((item: StackFrame) => {\n                if (count++ >= this.traceLevel) {\n                    return;\n                }\n                traces.push(item);\n            });\n        }\n        this.messages.push({\n            level,\n            time,\n            data,\n            message,\n            tags,\n            category,\n            trace: traces,\n            memoryUsage: process.memoryUsage().heapUsed\n        });\n\n        if (this.flushByCountInterval > 0 && this.messages.length >= this.flushByCountInterval) {\n            this.flush(this.messages);\n            this.messages = [];\n        }\n    }\n\n    public async flush(messages: MessageEntity[], final = false): Promise<void> {\n        const targetErrors: MessageEntity[] = [];\n\n        const targets = this.targets.map((target: AbstractTarget) => {\n            if (target.enabled) {\n                return target.collect(messages, final);\n                // try {\n                //\n                // } catch (exception) {\n                //     targetErrors.push({\n                //         level: LogLevel.WARNING,\n                //         time: new Date(),\n                //         data: [exception.name, exception.message, exception.stack],\n                //         message: 'Unable to send log via ' + target.constructor.name,\n                //         category: 'logger.core',\n                //         memoryUsage: process.memoryUsage().heapUsed,\n                //         trace: stackTraceParser.parse(new Error().stack)\n                //     });\n                // }\n            }\n            return Promise.resolve();\n        });\n        await Promise.all(targets).catch(async () => {\n            await this.flush(targetErrors, true);\n        });\n    }\n}\n"]}