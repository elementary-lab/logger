{"version":3,"file":"AbstractTarget.js","sourceRoot":"","sources":["AbstractTarget.ts"],"names":[],"mappings":";;;AAIA,MAAsB,cAAc;IAApC;QACW,YAAO,GAAG,IAAI,CAAC;QACf,WAAM,GAAe,EAAE,CAAC;QACxB,YAAO,GAAa,EAAE,CAAC;QACvB,YAAO,GAAa,EAAE,CAAC;QACvB,mBAAc,GAAG,CAAC,CAAC;IAoC9B,CAAC;IA/BU,SAAS,CAAC,MAA6B;QAC1C,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAChC,IAAI,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,QAAyB,EAAE,KAAK,GAAG,KAAK;QACzD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QACvF,IACI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC;YACxB,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,cAAc,GAAG,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC,EACrF;YACE,2EAA2E;YAC3E,MAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC;YAC9C,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;YACxB,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC;YACpB,IAAI,CAAC,cAAc,GAAG,iBAAiB,CAAC;SAC3C;IACL,CAAC;IAEM,cAAc,CACjB,QAAyB,EACzB,SAAqB,EAAE,EACvB,UAAoB,EAAE,EACtB,UAAoB,EAAE;QAEtB,cAAc;QACd,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,KAAoB,EAAE,EAAE;YAC5C,OAAO,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;IACP,CAAC;CACJ;AAzCD,wCAyCC","sourcesContent":["import { MessageEntity } from '../Entities/MessageEntity';\nimport { LogLevel } from '../Types';\nimport { TargetConfigInterface } from '../Interface/LoggerConfigInterface';\n\nexport abstract class AbstractTarget implements TargetConfigInterface {\n    public enabled = true;\n    public levels: LogLevel[] = [];\n    public exclude: string[] = [];\n    public include: string[] = [];\n    public exportInterval = 1;\n    public messages: MessageEntity[] | null;\n\n    abstract export(): Promise<void>;\n\n    public configure(config: TargetConfigInterface): void {\n        Object.keys(config).forEach(value => {\n            this[value] = config[value];\n        });\n    }\n\n    public async collect(messages: MessageEntity[], final = false): Promise<void> {\n        this.messages = this.filterMessages(messages, this.levels, this.include, this.exclude);\n        if (\n            this.messages.length > 0 &&\n            (final || (this.exportInterval > 0 && this.messages.length >= this.exportInterval))\n        ) {\n            // set exportInterval to 0 to avoid triggering export again while exporting\n            const oldExportInterval = this.exportInterval;\n            this.exportInterval = 0;\n            await this.export();\n            this.exportInterval = oldExportInterval;\n        }\n    }\n\n    public filterMessages(\n        messages: MessageEntity[],\n        levels: LogLevel[] = [],\n        include: string[] = [],\n        exclude: string[] = []\n    ): MessageEntity[] {\n        // TODO filter\n        return messages.filter((value: MessageEntity) => {\n            return levels.includes(value.level);\n        });\n    }\n}\n"]}